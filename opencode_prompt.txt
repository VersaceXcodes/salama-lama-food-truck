TASK: Create real API E2E auth tests (register -> logout -> sign-in) for a Vite+React+TS app using Vitest.

AGENT FILE CONTEXT - YOU MUST READ THESE FILES IN THE SANDBOX FIRST:
Before generating or fixing tests:
1) Read Store (Zustand) to confirm auth state shape, selectors, and actions.
   Candidates (first that exists):
   - /app/vitereact/src/store/main.tsx
2) Read Backend server for auth API endpoints (paths, payloads, responses).
   Candidates:
   - /app/backend/server.ts
3) Read Database schema (to understand constraints/defaults).
   Candidates:
   - /app/backend/db.sql
   Summarize only relevant parts (users table, unique email, required fields).
4) Read Frontend routes/config for aliases and navigation.
   - /app/vitereact/tsconfig.json (paths)
   - /app/vitereact/vite.config.ts (resolve.alias)
   - /app/vitereact/src/App.tsx (confirm login route path, e.g., "/login")
- Do NOT mock the API. Use the real backend running at ${import.meta.env.VITE_API_BASE_URL || "http://localhost:3000"}.
- Prefer direct component import if an auth view exists; otherwise test the App-level route.
- Place tests at: /app/vitereact/src/__tests__/auth.e2e.test.tsx
- Ensure vitest config exists (vitest.config.ts with jsdom, globals, setupFiles ./src/test/setup.ts) and src/test/setup.ts imports @testing-library/jest-dom.
- Ensure .env.test sets VITE_API_BASE_URL=http://localhost:3000.
- If "@/..." aliases are used but not configured, add Vite resolve.alias and tsconfig paths so "@/store/main" and "@/App" resolve correctly.
- Use a unique email per run to avoid duplicates (e.g., user${Date.now()}@example.com).
- Use BrowserRouter wrapper for direct view tests; use MemoryRouter initialEntries=[ "/login" ] for App-level tests.
- Never mock network; keep assertions on Zustand store:
  state.authentication_state.authentication_status.is_authenticated === true and state.authentication_state.auth_token truthy.
- Make selectors resilient to label/button variants:
  labels: /email address|email/i, /password/i;
  buttons: /sign in|log in|register|sign up|create/i.

Discovery instructions:
- Search for auth view under /app/vitereact/src/components/views (depth<=2) with filename containing /(login|signin|auth)/i.
- If found, import its default export and render it directly.
Outputs to create/update in /app/vitereact:
- vitest.config.ts
- src/test/setup.ts
- .env.test
- src/__tests__/auth.e2e.test.tsx

Constraints:
- No additional libraries beyond vitest/@testing-library/jsdom/user-event/react-dom testing utilities.
- Keep code TypeScript-friendly (tsx).

Additional guardrails:
- Do NOT hardcode real credentials in the test.
- If a sign-in-only flow is required, read VITE_REAL_TEST_EMAIL and VITE_REAL_TEST_PASSWORD from .env.test when present.
- Prefer a register-first flow with a unique timestamped email to avoid collisions.
- Always import the Zustand store via "@/store/main" and repair Vite/tsconfig aliases if they are missing.

REFERENCE-ONLY EXAMPLE (do NOT copy credentials; adapt patterns only):
```tsx
import React from 'react';
import { describe, it, expect, beforeEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { BrowserRouter } from 'react-router-dom';

import UV_SignIn from './UV_SignIn';
import { useAppStore } from '@/store/main';

// IMPORTANT: For reference only. Do NOT hardcode real credentials.
// If a sign-in-only flow is needed, read REAL_TEST_EMAIL and REAL_TEST_PASSWORD from .env.test.
// Otherwise prefer register-first with a timestamped unique email in a separate test.

const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <BrowserRouter>{children}</BrowserRouter>
);

describe('UV_SignIn (Vitest, real API)', () => {
  beforeEach(() => {
    localStorage.clear();
    // Ensure store starts not loading and unauthenticated (no token)
    useAppStore.setState((state) => ({
      authentication_state: {
        ...state.authentication_state,
        auth_token: null,
        authentication_status: {
          is_authenticated: false,
          is_loading: false,
        },
        error_message: null,
      },
      current_workspace: null,
    }));
  });

  it('signs in successfully with valid credentials', async () => {
    render(<UV_SignIn />, { wrapper: Wrapper });

    const emailInput = await screen.findByLabelText(/email address/i);
    const passwordInput = await screen.findByLabelText(/password/i);
    const submitButton = await screen.findByRole('button', { name: /sign in to your account/i });

    // Ensure inputs are enabled before typing
    await waitFor(() => {
      expect(emailInput).not.toBeDisabled();
      expect(passwordInput).not.toBeDisabled();
    });

    const user = userEvent.setup();
    // DO NOT hardcode credentials. If env vars exist, use them:
    // const REAL_EMAIL = import.meta.env.VITE_REAL_TEST_EMAIL;
    // const REAL_PASSWORD = import.meta.env.VITE_REAL_TEST_PASSWORD;

    // Example (reference-only):
    // await user.type(emailInput, REAL_EMAIL);
    // await user.type(passwordInput, REAL_PASSWORD);

    // Button should enable once both fields are filled
    await waitFor(() => expect(submitButton).not.toBeDisabled());
    await user.click(submitButton);

    // Loading indicator appears after submit
    await waitFor(() => expect(screen.getByText(/signing in/i)).toBeInTheDocument());

    // Wait for auth to complete and store to reflect authenticated state
    await waitFor(
      () => {
        const state = useAppStore.getState();
        expect(state.authentication_state.authentication_status.is_authenticated).toBe(true);
        expect(state.authentication_state.auth_token).toBeTruthy();
      },
      { timeout: 20000 }
    );
  }, 30000);
});
```
